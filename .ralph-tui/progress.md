# Ralph Progress Log

This file tracks progress across iterations. Agents update this file
after each iteration and it's included in prompts for context.

## Codebase Patterns (Study These First)

- **Expo SDK 54** with New Architecture enabled, TypeScript strict mode
- **Entry point**: `expo-router/entry` (set in `package.json` `main` field) — no `App.tsx` or `index.ts`
- **File-based routing**: `app/` directory with Expo Router v6. Route groups: `(auth)` for unauthenticated screens, `(main)` for authenticated screens
- **NativeWind v4**: Configured via `babel.config.js` (preset), `metro.config.js` (withNativeWind wrapper), `tailwind.config.js`, and `global.css`. Import `../global.css` in root `_layout.tsx`
- **Design tokens**: BeerBot palette in `tailwind.config.js` — `brand` (amber/gold #f59e0b), `dark` (navy #1a1a2e)
- **State management**: Zustand stores in `lib/stores/`, TanStack Query client in `lib/query-client.ts`
- **Types**: Shared API types in `types/api.ts`
- **Database**: Supabase migrations in `supabase/migrations/`, seed data in `supabase/seed.sql`. Custom enums: `tap_status`, `order_status`. Auto-updated `updated_at` via trigger function.
- **Deep link scheme**: `beerbot://` (configured in `app.json`)
- **Path aliases**: `@/*` maps to project root via `tsconfig.json` `paths`
- **Supabase client**: `lib/supabase.ts` — uses `expo-secure-store` for session storage, env vars `EXPO_PUBLIC_SUPABASE_URL` / `EXPO_PUBLIC_SUPABASE_ANON_KEY`
- **Auth store**: `lib/stores/auth-store.ts` — Zustand store with Supabase session/user, `initialize()` returns cleanup function for auth listener
- **RLS pattern**: Public tables (venues, beers, taps, tap_pricing) use `TO anon, authenticated` SELECT. User-owned data (orders, order_events) filters by `auth.uid()`. Admin tables (admin_pour_logs) have no app-user policies — service_role only.
- **Reanimated SharedValue type**: Import `type SharedValue` directly from `react-native-reanimated`, NOT `Animated.SharedValue` (the namespace doesn't export it in v4).
- **API layer pattern**: `lib/api/{resource}.ts` — typed query functions using Supabase client, with RPC calls for computed queries and `.select()` with nested joins for relational data. Realtime subscriptions via `supabase.channel()` + `postgres_changes`.
- **Edge Functions pattern**: `supabase/functions/{fn-name}/index.ts` — Deno runtime with ESM imports from `esm.sh`. Use two Supabase clients: user JWT client (for identity) + service_role client (for privileged writes). Must exclude `supabase/functions` from `tsconfig.json` (Deno != Node).
- **Edge Function invocation**: `supabase.functions.invoke<T>(fnName, { method })` — auto-passes user's auth token. Returns typed `{ data, error }`.
- **Cron-safe DB functions**: Use `FOR UPDATE SKIP LOCKED` when writing PL/pgSQL functions called by pg_cron — prevents deadlocks if jobs overlap. Prefer SQL `SET col = col + X` for atomic increments over Supabase JS read-then-write.

---

## 2026-02-11 - US-001
- What was implemented:
  - Scaffolded Expo project with SDK 54+ and TypeScript strict mode
  - Installed and configured NativeWind v4 with Tailwind CSS and BeerBot design tokens (amber/gold brand palette, dark navy theme)
  - Installed and configured Expo Router v6 with file-based navigation and auth layout groups `(auth)` and `(main)`
  - Installed Zustand for global state management (auth store created)
  - Installed TanStack Query for server state caching (query client configured)
  - Installed react-native-reanimated and lottie-react-native for animations
  - Installed expo-location, expo-secure-store, expo-notifications
  - Installed react-native-qrcode-svg and react-native-svg for QR generation
  - Configured app.json with BeerBot branding (name, slug, scheme `beerbot://`, dark theme, iOS/Android permissions)
  - Created folder structure: `app/(auth)/`, `app/(main)/`, `lib/`, `components/`, `hooks/`, `types/`
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes
- Files changed:
  - `package.json` — main entry changed to `expo-router/entry`, all deps added
  - `app.json` — BeerBot branding, scheme, plugins, permissions
  - `tsconfig.json` — strict mode, path aliases, NativeWind types
  - `babel.config.js` — NativeWind preset
  - `metro.config.js` — NativeWind metro wrapper
  - `tailwind.config.js` — BeerBot design tokens
  - `global.css` — Tailwind directives
  - `nativewind-env.d.ts` — NativeWind type reference
  - `eslint.config.js` — Expo ESLint flat config
  - `app/_layout.tsx` — Root layout with QueryClientProvider
  - `app/index.tsx` — Entry redirect to auth/welcome
  - `app/(auth)/_layout.tsx` — Auth stack layout
  - `app/(auth)/welcome.tsx` — Placeholder welcome screen
  - `app/(main)/_layout.tsx` — Main stack layout
  - `app/(main)/venues/index.tsx` — Placeholder venues screen
  - `lib/stores/auth-store.ts` — Zustand auth store
  - `lib/query-client.ts` — TanStack Query client config
  - `components/ThemedText.tsx` — Base themed text component
  - `hooks/useAppState.ts` — App state change hook
  - `types/api.ts` — Full API types (Venue, Beer, Tap, TapWithBeer, Order, OrderStatus)
  - Removed: `App.tsx`, `index.ts` (replaced by Expo Router)
- **Learnings:**
  - NativeWind v4 requires three config files: babel preset, metro wrapper, and tailwind config with `nativewind/preset`
  - `expo lint` auto-installs eslint + eslint-config-expo if not present; it scans `app/`, `src/`, `components/` dirs — directories with only non-TS files (e.g., `.gitkeep`) cause a lint error
  - Expo Router typed routes via `experiments.typedRoutes: true` in `app.json`
  - Expo SDK 54 uses React 19.1, react-native 0.81
---

## 2026-02-11 - US-002
- What was implemented:
  - Created `supabase/migrations/` and `supabase/` directory structure
  - Single consolidated migration `20260211000000_initial_schema.sql` with all 8 tables:
    - `users` — uuid PK, unique email, age verification fields, stripe_customer_id, updated_at trigger
    - `venues` — uuid PK, name, address, lat/lng, is_active, mobile_ordering_enabled
    - `beers` — uuid PK, name, style, abv, description, image_url
    - `taps` — uuid PK, FK to venues/beers, tap_number, status enum, oz_remaining, temperature fields, updated_at trigger
    - `tap_pricing` — uuid PK, FK to taps, price_12oz, pour_size_oz, currency
    - `orders` — uuid PK, FKs to users/venues/taps/beers, quantity, pricing, status enum, QR fields, Stripe fields, timestamps, updated_at trigger
    - `order_events` — uuid PK, FK to orders, event_type, jsonb metadata
    - `admin_pour_logs` — uuid PK, FKs to taps/users, pour_size_oz, master_code_used, reason
  - Custom PostgreSQL enums: `tap_status` (active/inactive/maintenance), `order_status` (9 states)
  - Shared `update_updated_at()` trigger function for auto-updating timestamps
  - 5 indexes: orders.user_id, orders.venue_id, orders.status, orders.qr_code_token, taps.venue_id
  - Seed data in `supabase/seed.sql`: 1 venue (The Hoppy Spot), 3 beers (IPA, Stout, Wheat), 3 taps with pricing
  - `npx tsc --noEmit` passes (SQL files don't affect TypeScript)
- Files changed:
  - `supabase/migrations/20260211000000_initial_schema.sql` — full schema migration (new)
  - `supabase/seed.sql` — development seed data (new)
- **Learnings:**
  - SQL migrations are pure SQL files outside the TypeScript compilation scope, so they don't affect `tsc --noEmit`
  - Using deterministic UUIDs in seed data (e.g., `00000000-0000-0000-0000-000000000001`) makes cross-referencing FKs in seed files easy and reproducible
  - Supabase convention: migrations in `supabase/migrations/` with timestamp prefix, seed data in `supabase/seed.sql`
  - The `types/api.ts` TypeScript types already match the database schema 1:1 (established in US-001)
---

## 2026-02-11 - US-003
- What was implemented:
  - New migration `supabase/migrations/20260211100000_auth_rls.sql` with:
    - `handle_new_user()` trigger function (SECURITY DEFINER) that auto-creates a `users` row on `auth.users` INSERT, mapping `id`, `email`, and optional `full_name` from `raw_user_meta_data`
    - RLS enabled on ALL 8 tables (users, venues, beers, taps, tap_pricing, orders, order_events, admin_pour_logs)
    - `users`: SELECT/UPDATE own row only (`id = auth.uid()`)
    - `venues`, `beers`, `taps`, `tap_pricing`: publicly readable (`TO anon, authenticated`)
    - `orders`: SELECT/INSERT by owning user (`user_id = auth.uid()`)
    - `order_events`: SELECT by order owner via EXISTS subquery join to orders
    - `admin_pour_logs`: no app-user policies — only accessible via service_role key (bypasses RLS)
  - Installed `@supabase/supabase-js` and `react-native-url-polyfill`
  - Created `lib/supabase.ts` — Supabase client configured with `expo-secure-store` adapter for auth token persistence, env vars for URL/key
  - Updated `lib/stores/auth-store.ts` — Zustand store now integrates with Supabase auth (session, user, onAuthStateChange listener, initialize/cleanup pattern)
  - Created `.env.example` documenting required env vars
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes
- Files changed:
  - `supabase/migrations/20260211100000_auth_rls.sql` — RLS migration (new)
  - `lib/supabase.ts` — Supabase client config (new)
  - `lib/stores/auth-store.ts` — updated with Supabase session integration
  - `package.json` — added `@supabase/supabase-js`, `react-native-url-polyfill`
  - `.env.example` — env var documentation (new)
- **Learnings:**
  - Supabase `handle_new_user()` must be `SECURITY DEFINER` to write to `public.users` from an `auth.users` trigger context
  - `react-native-url-polyfill` is still needed with `@supabase/supabase-js` v2 on React Native
  - For `admin_pour_logs`, enabling RLS with no policies effectively restricts to service_role only (which bypasses RLS)
  - Expo uses `EXPO_PUBLIC_` prefix for client-accessible env vars (equivalent to `NEXT_PUBLIC_` in Next.js)
  - `expo-secure-store` works as a drop-in Supabase auth storage adapter with `getItemAsync`/`setItemAsync`/`deleteItemAsync`
---

## 2026-02-11 - US-012
- What was implemented:
  - Built full welcome/onboarding screen at `app/(auth)/welcome.tsx` with:
    - Animated Lottie hero area with beer mug animation (placeholder branding)
    - 3-slide swipeable carousel: "Order Your Beer", "Verify Your Age", "Scan & Pour"
    - Smooth page transitions using `react-native-reanimated` (withSpring, interpolate)
    - Pan gesture handling via `react-native-gesture-handler` GestureDetector (works iOS + Android)
    - Animated dot indicators that expand/contract based on active slide
    - Fade-in entrance animation for the Lottie hero
    - "Get Started" CTA button navigating to registration screen
    - "I already have an account" link navigating to login screen
    - NativeWind + BeerBot dark theme with amber/gold accents
    - Responsive layout using flex ratios and useWindowDimensions (iPhone SE to Pro Max)
    - Safe area insets via useSafeAreaInsets
  - Created `assets/welcome-animation.json` — custom Lottie animation (beer mug with foam, bubbles, gentle rocking)
  - Created placeholder `app/(auth)/register.tsx` and `app/(auth)/login.tsx` for navigation targets
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes
- Files changed:
  - `app/(auth)/welcome.tsx` — full welcome screen with carousel (rewritten from placeholder)
  - `app/(auth)/register.tsx` — placeholder registration screen (new)
  - `app/(auth)/login.tsx` — placeholder login screen (new)
  - `assets/welcome-animation.json` — Lottie animation file (new)
- **Learnings:**
  - `Animated.SharedValue` namespace type doesn't work in reanimated v4 — must import `type SharedValue` directly from `react-native-reanimated`
  - Building a custom carousel with `GestureDetector` + `Gesture.Pan()` gives full control over swipe thresholds and animation curves vs. using a third-party carousel library
  - `activeOffsetX` + `failOffsetY` on Pan gesture prevents vertical scroll interference while allowing horizontal swipes
  - Lottie JSON can be hand-authored for simple placeholder animations — shapes (rc, el) + keyframed transforms + opacity
  - Typed routes with Expo Router require target screens to exist, even as placeholders, for `router.push()` to pass `tsc`
---

## 2026-02-11 - US-004
- What was implemented:
  - Created `lib/api/venues.ts` with typed query functions:
    - `fetchVenues(params?)` — fetches all active venues; when lat/lng provided, calls `get_venues_nearby` RPC for Haversine proximity sorting with `distance_miles`
    - `fetchVenueTaps(venueId)` — fetches active taps for a venue with joined beer data (via Supabase nested select `beers (*)`) and pricing (`tap_pricing (price_12oz)`), computes `availability_status` per tap based on `oz_remaining` vs `low_threshold_oz`
    - `subscribeTaps(venueId, onUpdate)` — Supabase realtime subscription for taps table filtered by venue, returns `RealtimeChannel` for cleanup
  - Created `supabase/migrations/20260211200000_venues_nearby.sql`:
    - `get_venues_nearby(user_lat, user_lng)` SQL function using Haversine formula (3959 * acos(...)) for distance in miles
    - `LEAST/GREATEST` clamping on acos input to prevent NaN from floating-point drift
    - Returns all active venues sorted by distance when coordinates provided, by name otherwise
  - Updated `types/api.ts`:
    - Added `VenueWithDistance` interface extending `Venue` with `distance_miles: number | null`
    - Added `TapPricing` interface for tap pricing rows
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes
- Files changed:
  - `supabase/migrations/20260211200000_venues_nearby.sql` — proximity sorting SQL function (new)
  - `lib/api/venues.ts` — venue/tap query functions + realtime subscription (new)
  - `types/api.ts` — added `VenueWithDistance`, `TapPricing` types
- **Learnings:**
  - Supabase `.rpc()` calls invoke SQL functions; the TypeScript return type is `unknown[]` by default — cast to the expected type after the call
  - Supabase nested select syntax `beers (*)` joins via FK automatically; the result key is the table name (plural `beers`), not the FK column name (`beer_id`)
  - Haversine `acos()` can receive values slightly outside [-1, 1] due to floating-point precision — wrapping with `LEAST(1.0, GREATEST(-1.0, ...))` prevents `NaN`
  - Supabase realtime `postgres_changes` filter syntax: `venue_id=eq.${venueId}` — matches PostgREST filter format
  - `STABLE` volatility on the SQL function is correct since it only reads data and results are consistent within a transaction
---

## 2026-02-11 - US-009
- What was implemented:
  - Created `supabase/migrations/20260211300000_verification_attempts.sql`:
    - `verification_attempts` table for rate limiting (user_id, session_id, status, created_at)
    - Indexes on user_id and created_at for efficient rate limit queries
    - RLS enabled: users can SELECT own attempts only; INSERT is service_role only (Edge Functions)
  - Created `supabase/functions/create-verification-session/index.ts` (Deno Edge Function):
    - Authenticates user via JWT from Authorization header
    - Checks if user is already age-verified (returns 400 if so)
    - Rate limits: max 5 verification attempts per user per 24-hour window (returns 429)
    - Creates Veriff session via their REST API with user metadata and callback URL
    - Logs attempt to `verification_attempts` table via service_role client
    - Returns session URL, session ID, and session token to mobile app
    - CORS headers for preflight OPTIONS requests
  - Created `supabase/functions/verification-webhook/index.ts` (Deno Edge Function):
    - Verifies webhook authenticity via HMAC-SHA256 signature (x-hmac-signature header)
    - Handles Veriff decision codes: approved (9001), declined (9102), resubmit (9103), expired (9104)
    - On approved: sets `users.age_verified = true`, `age_verification_ref = sessionId`, `age_verified_at = now()`
    - On declined/resubmit/expired: updates attempt status only, does NOT modify user age_verified
    - Does NOT store ID images or personal data — only status, timestamp, and reference ID
  - Created `lib/api/verification.ts` with typed functions:
    - `createVerificationSession()` — invokes create-verification-session Edge Function, returns `VerificationSession`
    - `checkVerificationStatus()` — reads user profile from `users` table, returns `VerificationStatus`
  - Updated `types/api.ts`:
    - Added `VerificationAttemptStatus` union type
    - Added `VerificationAttempt`, `VerificationSession`, `VerificationStatus` interfaces
  - Updated `tsconfig.json` to exclude `supabase/functions` (Deno runtime, not Expo/Node)
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes
- Files changed:
  - `supabase/migrations/20260211300000_verification_attempts.sql` — rate limiting table (new)
  - `supabase/functions/create-verification-session/index.ts` — session creation Edge Function (new)
  - `supabase/functions/verification-webhook/index.ts` — webhook handler Edge Function (new)
  - `lib/api/verification.ts` — typed verification API functions (new)
  - `types/api.ts` — added verification types
  - `tsconfig.json` — excluded `supabase/functions` from Expo TypeScript compilation
- **Learnings:**
  - Supabase Edge Functions use Deno runtime with ESM imports from `https://esm.sh/` — these are incompatible with Node/Expo's TypeScript compiler, so `supabase/functions` must be excluded in `tsconfig.json`
  - Veriff webhook uses HMAC-SHA256 for signature verification (`x-hmac-signature` header) — use Web Crypto API (`crypto.subtle`) in Deno rather than Node.js `createHmac`
  - Edge Functions use two Supabase clients: one with the user's JWT (for auth identity) and one with service_role key (for privileged writes that bypass RLS)
  - Rate limiting in Edge Functions is done by querying the `verification_attempts` table with a time window filter (`gte created_at`) and `count: 'exact'` + `head: true` for efficient counting
  - `supabase.functions.invoke()` automatically passes the user's auth token from the client — no manual header setup needed in the mobile app
  - Veriff `vendorData` field is used to pass the user ID through the verification flow so the webhook can associate the result back to the correct user
  - Note: `@veriff/react-native-sdk` was NOT installed because Veriff's web-based session URL flow works via in-app browser/WebView without requiring a native SDK. The native SDK can be added later for a more polished UX if needed.
---

## 2026-02-11 - US-013
- What was implemented:
  - Replaced placeholder `app/(auth)/register.tsx` with full registration screen:
    - Form fields: Full Name (autoCapitalize words), Email (email keyboard), Password (secureTextEntry)
    - Client-side validation on blur: name required, email format, password min 8 chars
    - Animated password strength indicator bar (weak=red/33%, medium=amber/66%, strong=green/100%) using reanimated `withTiming`
    - Show/Hide password toggle button inside password field
    - Submit calls `supabase.auth.signUp()` with email, password, and `full_name` in `raw_user_meta_data`
    - On success: `router.replace('/(main)/venues')` — auth store listener picks up session automatically
    - On failure: error banner with mapped Supabase error messages (already registered, invalid email, etc.)
    - Loading state: button disabled + ActivityIndicator spinner during signUp
    - KeyboardAvoidingView (iOS padding, Android height) wrapping ScrollView with `keyboardShouldPersistTaps="handled"`
    - Back navigation via `router.back()` to welcome screen
    - FadeIn entrance animation on form content
    - BeerBot dark theme (bg-dark, text-white, brand amber accents)
    - Safe area insets via useSafeAreaInsets
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes (0 errors, 0 warnings)
- Files changed:
  - `app/(auth)/register.tsx` — full registration screen (rewritten from placeholder)
- **Learnings:**
  - `catch {}` (no binding) is valid in modern TypeScript/ESLint and avoids unused-var warnings — preferred over `catch (_e)`
  - Supabase `signUp()` accepts `options.data` for `raw_user_meta_data` which the `handle_new_user()` trigger reads to populate `users.full_name`
  - For password visibility toggle, using `absolute` positioning with `right-4 top-0 bottom-0 justify-center` in NativeWind creates a properly centered toggle inside TextInput without needing a wrapper component
  - `keyboardShouldPersistTaps="handled"` on ScrollView prevents keyboard dismissal when tapping buttons — essential for form UX
---

## 2026-02-11 - US-005
- What was implemented:
  - Created `supabase/migrations/20260211400000_create_order_rpc.sql`:
    - `create_order_atomic(p_user_id, p_tap_id, p_quantity, p_expires_minutes)` SQL function (SECURITY DEFINER)
    - Atomic transaction: validates all preconditions → decrements `oz_remaining` → creates order → logs `created` event in `order_events`
    - Validations: user `age_verified = true`, tap `status = 'active'`, tap `temp_ok = true`, venue `is_active = true`, venue `mobile_ordering_enabled = true`, `oz_remaining > low_threshold_oz`, sufficient inventory for requested quantity
    - Uses `FOR UPDATE` row lock on taps to prevent concurrent inventory race conditions
    - Sets order status to `pending_payment`, calculates `total_amount` from `tap_pricing`, sets `expires_at` to now + 15 minutes (configurable via parameter)
    - Returns structured JSON with error codes on validation failure, or order details on success
  - Created `supabase/functions/create-order/index.ts` (Deno Edge Function):
    - Authenticates user via JWT from Authorization header (same pattern as create-verification-session)
    - Validates request body (`tap_id` required, `quantity` optional positive integer)
    - Calls `create_order_atomic` RPC via service_role client (bypasses RLS for cross-table atomic transaction)
    - Maps error codes to appropriate HTTP status codes (403, 404, 409)
    - CORS headers for preflight OPTIONS requests
  - Created `lib/api/orders.ts` with typed functions:
    - `createOrder(request)` — invokes create-order Edge Function, returns `CreateOrderResponse`
    - `getOrder(orderId)` — fetches single order by ID via Supabase client (RLS-filtered)
    - `getOrderHistory({ limit, offset })` — paginated order history, newest first, default 20 per page
  - Updated `types/api.ts`:
    - Added `CreateOrderRequest` interface (`tap_id`, optional `quantity`)
    - Added `CreateOrderResponse` interface (order details returned from Edge Function)
    - Added `OrderEvent` interface (order_events table row type)
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes
- Files changed:
  - `supabase/migrations/20260211400000_create_order_rpc.sql` — atomic order creation RPC (new)
  - `supabase/functions/create-order/index.ts` — order creation Edge Function (new)
  - `lib/api/orders.ts` — typed order API functions (new)
  - `types/api.ts` — added `CreateOrderRequest`, `CreateOrderResponse`, `OrderEvent`
- **Learnings:**
  - `FOR UPDATE` row-level lock in PostgreSQL is essential for atomic inventory operations — prevents concurrent orders from overselling
  - SECURITY DEFINER on the RPC function means it runs with the function owner's permissions (typically superuser), allowing cross-table reads/writes regardless of RLS. The Edge Function calls it via service_role client.
  - Returning `jsonb` from a PL/pgSQL function allows structured error reporting without raising exceptions — the caller checks for an `error` key in the result
  - Supabase `.rpc()` with service_role client bypasses RLS entirely, so the atomic function can read users, venues, taps, tap_pricing, and write orders + order_events in a single transaction
  - `(p_expires_minutes || ' minutes')::interval` is valid PostgreSQL syntax for constructing an interval from a parameter
---

## 2026-02-11 - US-014
- What was implemented:
  - Replaced placeholder `app/(auth)/login.tsx` with full login screen:
    - Email and password fields with client-side validation on blur
    - Show/Hide password toggle button inside password field
    - "Forgot password?" link navigating to `/(auth)/forgot-password`
    - Submit triggers `supabase.auth.signInWithPassword()` with error mapping
    - On success: saves email to SecureStore for biometric, navigates to `/(main)/venues`
    - On failure: displays mapped error messages (Invalid credentials, Email not confirmed, Too many requests)
    - Biometric login: checks `expo-local-authentication` hardware + enrollment + stored previous login email
    - Shows Face ID / Fingerprint button with "or" divider when biometric is available
    - Biometric flow: authenticates locally → checks Supabase session validity → navigates or falls back
    - Loading state with disabled buttons + ActivityIndicator during auth
    - BeerBot dark theme, FadeIn animation, KeyboardAvoidingView, safe area insets
  - Created `app/(auth)/forgot-password.tsx` with full password reset flow:
    - Email input with validation, calls `supabase.auth.resetPasswordForEmail()`
    - Success state showing "Check your email" confirmation
    - Uses `beerbot://reset-password` deep link as redirect URL
  - Updated `app/_layout.tsx` with AuthGate wrapper:
    - Initializes auth store listener on mount (returns cleanup)
    - Auto-redirects authenticated users from `(auth)` → `(main)/venues`
    - Auto-redirects unauthenticated users from `(main)` → `(auth)/welcome`
    - Session persistence: Supabase client already stores tokens in `expo-secure-store` (configured in US-003)
  - Updated `app.json`: added `expo-local-authentication` plugin with Face ID permission
  - Installed `expo-local-authentication` package
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes (0 errors, 0 warnings)
- Files changed:
  - `app/(auth)/login.tsx` — full login screen with biometric auth (rewritten from placeholder)
  - `app/(auth)/forgot-password.tsx` — password reset screen (new)
  - `app/_layout.tsx` — AuthGate with session check and auth redirect (updated)
  - `app.json` — added expo-local-authentication plugin + Face ID permission
  - `package.json` — added `expo-local-authentication` dependency
- **Learnings:**
  - `expo-local-authentication` requires both `hasHardwareAsync()` AND `isEnrolledAsync()` to be true — hardware present doesn't mean biometrics are configured
  - `supportedAuthenticationTypesAsync()` returns an array of `AuthenticationType` enums — check for `FACIAL_RECOGNITION` (1) or `FINGERPRINT` (2) to show the right label
  - Biometric auth only gates local device access — the actual session token is already persisted in SecureStore by the Supabase client. After biometric confirmation, call `getSession()` to verify the token is still valid.
  - For auth redirect in Expo Router, use `useSegments()` to detect the current route group and `router.replace()` to redirect. Must guard with `isLoading` to avoid redirecting before session check completes.
  - Expo lint enforces `react/no-unescaped-entities` — use `&apos;` for apostrophes in JSX text content
  - The `AuthGate` pattern (wrapper component in root layout) is the standard Expo Router approach for auth-gated navigation — avoids race conditions by checking auth state before rendering routes
---

## 2026-02-11 - US-006
- What was implemented:
  - Created `supabase/functions/generate-qr-token/index.ts` (Deno Edge Function):
    - Authenticates user via JWT from Authorization header
    - Validates order exists, belongs to requesting user, and has status `paid` or `ready_to_redeem`
    - Idempotent: returns existing token if one was already generated
    - Creates JWT signed with HMAC-SHA256 using `QR_TOKEN_SECRET` (Supabase secret)
    - JWT payload: `order_id`, `tap_id`, `venue_id`, `user_id`, `exp`, `iat`
    - Token expiration matches `order.expires_at` (or defaults to 15 minutes)
    - Stores token in `orders.qr_code_token`, sets `qr_expires_at`, updates status to `ready_to_redeem`
    - Logs `qr_token_generated` event to `order_events`
    - Uses `djwt` library (Deno JWT) for JWT creation with Web Crypto API key import
  - Created `supabase/functions/verify-qr-token/index.ts` (Deno Edge Function):
    - Authenticates caller (venue staff/admin) via JWT
    - Verifies QR token JWT: signature valid, not expired
    - Validates order exists, token matches stored `qr_code_token`, order status is `ready_to_redeem`
    - Cross-checks JWT payload fields (venue_id, tap_id, user_id) against order record
    - Single-use enforcement: marks order as `redeemed` with optimistic lock (`WHERE status = 'ready_to_redeem'`)
    - Sets `redeemed_at` timestamp, logs `redeemed` event to `order_events`
    - Returns detailed error codes: `INVALID_TOKEN`, `ORDER_NOT_FOUND`, `TOKEN_MISMATCH`, `ALREADY_REDEEMED`, `ORDER_EXPIRED`, etc.
  - Created `lib/utils/qr.ts` with client-side helpers:
    - `generateQrDataString(token)` — produces `beerbot://redeem?token=<jwt>` deep link string for QR code rendering
    - `generateQrToken(orderId)` — invokes `generate-qr-token` Edge Function via `supabase.functions.invoke()`
    - `verifyQrToken(token)` — invokes `verify-qr-token` Edge Function via `supabase.functions.invoke()`
  - Updated `types/api.ts`:
    - Added `GenerateQrTokenRequest`, `GenerateQrTokenResponse`, `VerifyQrTokenRequest`, `VerifyQrTokenResponse` interfaces
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes
- Files changed:
  - `supabase/functions/generate-qr-token/index.ts` — QR token generation Edge Function (new)
  - `supabase/functions/verify-qr-token/index.ts` — QR token verification Edge Function (new)
  - `lib/utils/qr.ts` — client-side QR helpers (new)
  - `types/api.ts` — added QR token request/response types
- **Learnings:**
  - Deno has `djwt` (`https://deno.land/x/djwt@v3.0.2/mod.ts`) for JWT operations — uses Web Crypto API (`crypto.subtle.importKey`) for HMAC keys, not Node's `createHmac`
  - `djwt` `create()` requires a `CryptoKey` object, not a raw string — must import key via `crypto.subtle.importKey("raw", ...)` with `{ name: "HMAC", hash: "SHA-256" }`
  - `getNumericDate()` from `djwt` converts a Date to a numeric Unix timestamp for JWT `exp`/`iat` claims
  - The `qr_code_token` column already existed in the initial schema (US-002) with UNIQUE constraint and index — no migration needed
  - Idempotent token generation (return existing token if already generated) prevents duplicate tokens and simplifies client retry logic
  - Optimistic locking via `.eq("status", "ready_to_redeem")` in the update query ensures single-use: concurrent redemption attempts will fail because only the first one matches the WHERE clause
  - `beerbot://redeem?token=<jwt>` deep link format leverages the existing `beerbot://` scheme configured in `app.json`, enabling venue scanning devices to trigger the verification flow
  - `QR_TOKEN_SECRET` must be set as a Supabase secret (`supabase secrets set QR_TOKEN_SECRET=<value>`) — it's separate from the Supabase JWT secret
---

## 2026-02-11 - US-007
- What was implemented:
  - Installed `@stripe/stripe-react-native` in the Expo project
  - Created `supabase/functions/create-payment-intent/index.ts` (Deno Edge Function):
    - Authenticates user via JWT from Authorization header
    - Validates order exists, belongs to requesting user, and has status `pending_payment`
    - Creates or retrieves Stripe Customer for the user (links `stripe_customer_id` to users table)
    - Creates Stripe PaymentIntent with amount from `order.total_amount` (converted to cents)
    - PaymentIntent metadata includes: `order_id`, `user_id`, `venue_id`, `tap_id`
    - Uses idempotency key (`order_{order_id}`) to prevent duplicate charges
    - Idempotent: if `stripe_payment_intent_id` already exists on order, retrieves existing intent
    - Stores `stripe_payment_intent_id` on the order record
    - Logs `payment_intent_created` event to `order_events`
    - Creates ephemeral key for mobile SDK payment sheet
    - Returns `client_secret`, `ephemeral_key`, `customer_id`, `payment_intent_id`
    - CORS headers for preflight OPTIONS requests
  - Created `lib/api/payments.ts` with typed functions:
    - `createPaymentIntent(request)` — invokes Edge Function, returns `CreatePaymentIntentResponse`
    - `initializePaymentSheet(orderId)` — creates PaymentIntent + configures native Stripe payment sheet with Apple Pay, Google Pay, and card support
    - `presentPayment()` — presents payment sheet, returns `true` on success, `false` on cancel
    - `getStripePublishableKey()` — returns publishable key for StripeProvider initialization
  - Updated `types/api.ts`:
    - Added `CreatePaymentIntentRequest` interface (`order_id`)
    - Added `CreatePaymentIntentResponse` interface (`client_secret`, `ephemeral_key`, `customer_id`, `payment_intent_id`)
  - Configured `@stripe/stripe-react-native` Expo plugin in `app.json` with `merchantIdentifier` and `enableGooglePay`
  - Added `EXPO_PUBLIC_STRIPE_PUBLISHABLE_KEY` to `.env.example`
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes
- Files changed:
  - `supabase/functions/create-payment-intent/index.ts` — Stripe PaymentIntent Edge Function (new)
  - `lib/api/payments.ts` — typed payment API functions (new)
  - `types/api.ts` — added payment request/response types
  - `app.json` — added @stripe/stripe-react-native plugin
  - `.env.example` — added Stripe publishable key env var
  - `package.json` — added `@stripe/stripe-react-native` dependency
- **Learnings:**
  - Stripe on Deno uses `https://esm.sh/stripe@14?target=deno` — the `?target=deno` query param is essential for Deno-compatible ESM build
  - `Stripe.createFetchHttpClient()` is needed in Deno since Node's `http` module isn't available — pass it as `httpClient` in the Stripe constructor options
  - Stripe amounts are in smallest currency unit (cents for USD) — multiply `total_amount` by 100 and round to avoid floating-point issues
  - Idempotency is achieved at two levels: (1) Stripe's `idempotencyKey` on `paymentIntents.create` prevents duplicate charges server-side, (2) checking for existing `stripe_payment_intent_id` on the order prevents redundant API calls
  - `@stripe/stripe-react-native` Expo plugin requires `merchantIdentifier` for Apple Pay (format: `merchant.com.domain.app`) and `enableGooglePay: true` for Android
  - `initPaymentSheet` + `presentPaymentSheet` is the recommended Stripe mobile SDK flow — it handles Apple Pay, Google Pay, and card entry in a single native UI
  - Ephemeral keys are short-lived Stripe API keys scoped to a single customer — needed by the mobile SDK to securely access customer data without exposing the secret key
  - `STRIPE_SECRET_KEY` must be set as a Supabase Edge Function secret (`supabase secrets set STRIPE_SECRET_KEY=sk_...`) — never exposed to the client
  - The `returnURL` in `initPaymentSheet` (`beerbot://payment-complete`) uses the existing deep link scheme for redirect-based payment methods (3D Secure, etc.)
---

## 2026-02-11 - US-008
- What was implemented:
  - Created `supabase/functions/stripe-webhook/index.ts` (Deno Edge Function):
    - Verifies Stripe webhook signature using `stripe.webhooks.constructEventAsync()` with `STRIPE_WEBHOOK_SECRET`
    - Handles `payment_intent.succeeded`: updates order status to `paid` (with `paid_at`), then generates QR token (inline JWT creation mirroring `generate-qr-token`), updates status to `ready_to_redeem`
    - Handles `payment_intent.payment_failed`: updates order status to `cancelled`, restores `oz_remaining` on the tap (read-then-write pattern)
    - Handles `charge.refunded`: finds order by `stripe_payment_intent_id`, updates status to `refunded`
    - Idempotent handling: checks `order_events` table for existing entries with matching `stripe_event_id` in metadata before processing; also checks order status to avoid reprocessing
    - All events logged to `order_events` table with Stripe event metadata (`stripe_event_id`, `payment_intent_id`, amounts, failure details)
    - Returns 200 OK on success (including duplicates), 500 on error for Stripe retry
    - No CORS headers needed (webhook from Stripe, not browser)
    - No user JWT auth needed (webhook authenticated via signature verification)
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes
- Files changed:
  - `supabase/functions/stripe-webhook/index.ts` — Stripe webhook handler Edge Function (new)
- **Learnings:**
  - Stripe webhook signature verification in Deno uses `stripe.webhooks.constructEventAsync()` (async version) — the sync `constructEvent()` requires Node's `crypto` module which isn't available in Deno
  - Webhook Edge Functions don't need CORS headers or user JWT authentication — they're called by Stripe directly, not from a browser
  - For idempotency, checking `order_events` metadata JSON field uses Supabase `.filter("metadata->>stripe_event_id", "eq", eventId)` — the `->>` operator extracts JSON text for comparison
  - Supabase JS client doesn't support `SET col = col + X` syntax — for atomic increments (restoring inventory), need read-then-write or an RPC function. Read-then-write is acceptable in webhook context since concurrent writes to the same tap are unlikely during failure handling
  - `STRIPE_WEBHOOK_SECRET` must be set as a Supabase secret (`supabase secrets set STRIPE_WEBHOOK_SECRET=whsec_...`) — obtained from Stripe Dashboard > Developers > Webhooks
  - QR token generation is inlined in the webhook handler rather than calling the `generate-qr-token` Edge Function, because Edge Functions can't easily invoke other Edge Functions internally — the inline approach mirrors the same JWT signing logic
---

## 2026-02-11 - US-010
- What was implemented:
  - Created `supabase/migrations/20260211500000_expire_stale_orders.sql`:
    - `expire_stale_orders()` PL/pgSQL function (SECURITY DEFINER) that finds all orders with `status = 'ready_to_redeem'` and `expires_at < now()`
    - Uses `FOR UPDATE SKIP LOCKED` to safely handle concurrent cron executions without deadlocks
    - For each expired order: updates status to `expired`, logs `expired` event to `order_events`, restores `oz_remaining` on the tap atomically via `SET oz_remaining = oz_remaining + (quantity * pour_size_oz)`
    - Returns JSON with `expired_count` and `expired_order_ids` for observability
    - Enables `pg_cron` extension and schedules `expire-stale-orders` job to run every minute (`* * * * *`)
  - Created `supabase/functions/process-expired-orders/index.ts` (Deno Edge Function):
    - Calls `expire_stale_orders()` RPC to first expire stale orders in the database
    - Fetches all orders with `status = 'expired'` that have a `stripe_payment_intent_id` (need refund)
    - For each expired order: calls `stripe.refunds.create()` with the `payment_intent` ID for full refund
    - On successful refund: updates order status to `refunded`, logs `refunded` event with Stripe refund metadata
    - Idempotency: checks for existing `refunded` event on the order before issuing Stripe refund
    - Handles Stripe refund failures gracefully: logs `refund_failed` event with `requires_manual_review: true` flag, continues processing remaining orders
    - Returns summary JSON: `expired_count`, `refunded_count`, `failed_count`, and per-order results
  - No client-side (Expo) changes needed — this is entirely backend/infrastructure
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes
- Files changed:
  - `supabase/migrations/20260211500000_expire_stale_orders.sql` — expire function + pg_cron schedule (new)
  - `supabase/functions/process-expired-orders/index.ts` — Stripe refund Edge Function (new)
- **Learnings:**
  - `FOR UPDATE SKIP LOCKED` in PostgreSQL is essential for cron jobs that may overlap — it skips rows locked by a concurrent execution rather than waiting/deadlocking
  - Unlike the `handlePaymentFailed` in stripe-webhook (which uses read-then-write for tap inventory restoration), the database function can use `SET oz_remaining = oz_remaining + X` directly in SQL — this is atomic and doesn't need the Supabase JS client limitation workaround
  - pg_cron on Supabase requires enabling the `pg_cron` extension (Pro plan+) and granting `USAGE ON SCHEMA cron TO postgres`
  - The two-phase approach (database function for expiration + Edge Function for Stripe refunds) separates concerns: the DB function handles fast, transactional state changes; the Edge Function handles slow, external API calls (Stripe)
  - `stripe.refunds.create({ payment_intent })` issues a full refund by default — no need to specify `amount` for full refunds
  - For scheduled Edge Function invocation, Supabase supports cron-based HTTP triggers or the function can be called by pg_cron via `pg_net` extension / Supabase scheduled functions feature
---

## 2026-02-11 - US-011
- What was implemented:
  - Created `supabase/functions/pour-start/index.ts` (Deno Edge Function):
    - Authenticates caller via service-role key comparison (not user JWT — PLC/Raspberry Pi backend uses service-role)
    - Accepts payload: `{ order_id, tap_id, quantity, pour_size_oz, token }`
    - Validates JWT token signature and expiration using `djwt` with HMAC-SHA256 (`QR_TOKEN_SECRET`)
    - Validates `tap_id` matches the token's embedded `tap_id` — returns `WRONG_TAP` with correct tap number on mismatch
    - Validates order exists, token matches stored `qr_code_token`, order status is `ready_to_redeem`
    - Validates tap conditions: `temp_ok = true` (returns `TEMP_NOT_READY`) and `oz_remaining >= required` (returns `INVENTORY_LOW` with remaining/required amounts)
    - On valid: transitions order `ready_to_redeem -> redeemed -> pouring` with optimistic locks
    - Returns `pour_command` payload with tap_number, quantity, pour_size_oz, total_oz for PLC consumption
    - Logs events to `order_events` (redeemed + pouring) and `admin_pour_logs`
    - Full error code set: `EXPIRED`, `WRONG_TAP`, `ALREADY_REDEEMED`, `TEMP_NOT_READY`, `INVENTORY_LOW`, `ORDER_NOT_FOUND`, `INVALID_TOKEN`
  - Created `supabase/functions/pour-complete/index.ts` (Deno Edge Function):
    - Authenticates caller via service-role key comparison
    - Accepts payload: `{ order_id, tap_id, actual_oz_poured }`
    - Validates order exists, `tap_id` matches, order status is `pouring`
    - Transitions order `pouring -> completed` with optimistic lock, sets `completed_at`
    - Calculates pour variance (actual vs expected oz) for quality tracking
    - Logs `completed` event to `order_events` with actual/expected/variance metadata
    - Logs to `admin_pour_logs` with actual oz poured
  - Updated `types/api.ts`:
    - Added `PourStartRequest`, `PourCommand`, `PourStartResponse` interfaces
    - Added `PourCompleteRequest`, `PourCompleteResponse` interfaces
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes
- Files changed:
  - `supabase/functions/pour-start/index.ts` — PLC pour start stub Edge Function (new)
  - `supabase/functions/pour-complete/index.ts` — PLC pour complete stub Edge Function (new)
  - `types/api.ts` — added PLC stub request/response types
- **Learnings:**
  - Service-role authentication for machine-to-machine endpoints differs from user JWT auth: compare the provided Bearer token directly against `SUPABASE_SERVICE_ROLE_KEY` rather than calling `auth.getUser()`
  - PLC endpoints don't need user identity — the order's `user_id` is already embedded in the order record and JWT token payload
  - Two-phase status transitions (`ready_to_redeem -> redeemed -> pouring`) with optimistic locks on each step ensure atomic state progression and prevent race conditions from concurrent pour attempts
  - `admin_pour_logs` table has a `NOT NULL` constraint on `admin_user_id` — for PLC-initiated pours, the order's `user_id` is used as a proxy since the PLC itself has no user identity
  - Returning the `correct_tap_number` in `WRONG_TAP` errors lets the PLC display which tap the customer should go to — better UX than just an error code
---

## 2026-02-11 - US-015
- What was implemented:
  - Created `app/(auth)/reset-password.tsx` with full password reset flow:
    - New password + confirm password fields with show/hide toggles
    - Validation: min 8 characters, passwords must match, field-level errors on blur
    - Accepts `access_token` and `refresh_token` via route params (from deep link)
    - Sets Supabase recovery session from tokens via `supabase.auth.setSession()`
    - On submit: calls `supabase.auth.updateUser({ password })` to change password
    - On success: shows confirmation message, auto-navigates to `/(main)/venues` after 1.5s
    - Error handling: expired/invalid links with "Request a new reset link" fallback
    - Loading state while verifying reset link, disabled buttons during submission
    - BeerBot dark theme, FadeIn animation, KeyboardAvoidingView, safe area insets
  - Updated `app/_layout.tsx` AuthGate:
    - Added deep link handling via `expo-linking` (getInitialURL + addEventListener)
    - Parses Supabase hash fragment tokens (`#access_token=...&refresh_token=...&type=recovery`)
    - Routes recovery deep links to `/(auth)/reset-password` with tokens as params
    - Added exception: authenticated users on `reset-password` are NOT redirected to main (allows password update before redirect)
  - Updated `app/(auth)/forgot-password.tsx`:
    - Changed success message to "Check your email for a reset link" to match AC exactly
  - Deep link scheme `beerbot://` already configured in `app.json` (from US-001)
  - `beerbot://reset-password` redirect URL already set in `forgot-password.tsx` (from US-014)
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes
- Files changed:
  - `app/(auth)/reset-password.tsx` — password reset deep link landing screen (new)
  - `app/_layout.tsx` — added deep link handling + reset-password AuthGate exception
  - `app/(auth)/forgot-password.tsx` — updated success message text
- **Learnings:**
  - Supabase password reset sends tokens as URL hash fragments (`#access_token=...&type=recovery`), not query params — must parse with `url.indexOf('#')` + `URLSearchParams(fragment)` manually
  - In React Native, `supabase.auth.setSession()` with the recovery tokens establishes a valid session that allows `updateUser({ password })` to work — this is the mobile equivalent of Supabase's automatic session detection on web
  - Expo Router's `useSegments()` returns typed tuples with `typedRoutes: true` — accessing `segments[1]` fails type checking. Cast to `string[]` first: `(segments as string[])[1]`
  - AuthGate must exempt `reset-password` from the "authenticated user on auth screen → redirect to main" rule, otherwise the user gets redirected before they can set a new password (the recovery session makes them "authenticated")
  - `expo-linking` `getInitialURL()` handles cold starts (app opened via deep link), while `addEventListener('url')` handles warm starts (app already running in background)
  - The `redirectTo` in `resetPasswordForEmail()` must match the deep link scheme + path (`beerbot://reset-password`) — Supabase appends tokens as hash fragments to this URL
---

## 2026-02-11 - US-016
- What was implemented:
  - Replaced placeholder `app/(main)/venues/index.tsx` with full venue selection screen:
    - Requests location permission on mount via `expo-location` with graceful denial handling
    - GPS granted: calls `fetchVenues()` with lat/lng → venues sorted by proximity via `get_venues_nearby` RPC
    - GPS denied: shows full venue list alphabetically (no distance info)
    - Nearest venue detection: venues within 200m (~0.124 mi) show "You're here!" badge with highlighted card (brand border + tinted background)
    - Distance badges on venue cards (e.g. "0.1 mi away", "528 ft away")
    - Search bar with real-time filtering by venue name or address, with clear button
    - Venue cards show: name, address, distance (if GPS), active tap count (green dot indicator), placeholder image area
    - `mobile_ordering_enabled=false` venues shown as "In-person only" (greyed out, not tappable, `opacity-50`)
    - Pull-to-refresh re-checks location permission + refetches venues and tap counts
    - Empty state: "No venues found" with contextual hint when search is active
    - Error state with friendly message
    - Loading state with ActivityIndicator while detecting location + fetching data
    - Tapping a venue navigates to `app/(main)/venues/[id].tsx`
    - TanStack Query for all data fetching: location, venues, tap counts — with caching and stale times
    - FadeIn/FadeInDown entrance animations for header, search bar, and venue cards (staggered)
    - BeerBot dark theme with brand amber accents
  - Added `fetchVenueActiveTapCounts()` to `lib/api/venues.ts`:
    - Fetches active taps for a list of venue IDs, returns `Record<string, number>` map
    - Used by venue cards to show active tap count per venue
  - Created placeholder `app/(main)/venues/[id].tsx` for navigation target (typed routes require target to exist)
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes (0 errors, 0 warnings)
- Files changed:
  - `app/(main)/venues/index.tsx` — full venue selection screen (rewritten from placeholder)
  - `app/(main)/venues/[id].tsx` — placeholder venue detail screen (new)
  - `lib/api/venues.ts` — added `fetchVenueActiveTapCounts` function
- **Learnings:**
  - Using TanStack Query for location permission requests works well — the `queryFn` handles the side effect of requesting permission, and `staleTime` prevents re-prompting on re-renders
  - Location query should have `retry: false` since permission denial is not a transient error
  - `FlatList` `contentContainerStyle` needs `flexGrow: 1` for `ListEmptyComponent` to center properly — but only when the list is empty, so use conditional spread
  - React hooks exhaustive-deps lint rule catches `const x = query.data ?? {}` creating new object references on every render — wrap in `useMemo` to stabilize
  - For venue cards with staggered entrance animations, `FadeInDown.delay(index * 60)` gives a nice cascading effect without being too slow
  - Expo Router typed routes with `experiments.typedRoutes: true` require the destination screen file to exist for `router.push()` to pass `tsc` — placeholder screens are necessary
  - 200 meters ≈ 0.124 miles — this is the "You're here!" threshold for nearby venue detection
---

## 2026-02-11 - US-017
- What was implemented:
  - Replaced placeholder `app/(main)/venues/[id].tsx` with full Beer List screen:
    - Collapsible venue header: venue name, address, 'Change venue' button; shrinks on scroll using reanimated `useAnimatedStyle` + `interpolate`
    - GPS proximity check: if user is far from venue (>0.5 mi), shows subtle yellow warning "You're not at this venue"
    - Beer cards showing: beer name, style, ABV, price (12oz), availability badge, temperature
    - Availability badges with color coding: green 'Available', yellow 'Low', red/grey 'Out'
    - Temperature display: shows degrees F if sensor data exists, 'N/A' if null
    - If `temp_ok=false`: blue 'Cooling down' badge with snowflake icon, beer card not tappable
    - 'Out' beers visually dimmed (`opacity-50`) and not tappable
    - 'Low' beers show warning text: 'Limited — order at the station'
    - Tapping available beer navigates to beer detail/order screen (future US)
    - Supabase realtime subscription on taps table for live updates via `subscribeTaps()` — merges updated tap fields into TanStack Query cache while preserving beer/pricing data
    - Pull-to-refresh via RefreshControl that refetches taps
    - Empty state: 'No beers on tap right now. Check back soon!'
    - Error state with pull-to-refresh hint
    - Loading state with ActivityIndicator
    - BeerBot dark theme with brand amber accents, FadeIn/FadeInDown entrance animations
  - Added `fetchVenue(venueId)` to `lib/api/venues.ts` — fetches a single venue by ID for the header
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes (0 errors, 0 warnings)
- Files changed:
  - `app/(main)/venues/[id].tsx` — full beer list screen (rewritten from placeholder)
  - `lib/api/venues.ts` — added `fetchVenue` function
- **Learnings:**
  - Reanimated `useAnimatedStyle` with `interpolate` + `Extrapolation.CLAMP` works well for collapsible headers driven by `FlatList` scroll — set `scrollEventThrottle={16}` and update a `useSharedValue` in `onScroll`
  - For realtime tap updates, the `subscribeTaps` callback only gets the raw `Tap` row (no joins) — must merge with cached `TapWithBeer` data to preserve `beer` and `price_12oz` fields, and recompute `availability_status` from `oz_remaining` / `low_threshold_oz`
  - `Location.getForegroundPermissionsAsync()` (no prompt) is better than `requestForegroundPermissionsAsync()` for secondary screens — avoids re-prompting when permission was already granted/denied on the venue selection screen
  - Supabase `decimal` columns come back as numbers in JS, but TypeScript doesn't know this — casting with `Number()` is safe for lat/lng used in Haversine calculations
---

## 2026-02-11 - US-018
- What was implemented:
  - Created `app/(main)/order/configure.tsx` — Beer Detail and Order Configuration screen:
    - Beer image area (branded placeholder with beer mug icon and style label, or image if `image_url` exists)
    - Beer detail header: name, style, ABV, description
    - Tap number badge: "Tap #3" style with brand amber styling
    - Live availability badge (Available/Low/Out) and temperature display with realtime updates
    - Fixed serving size display: "12 oz"
    - Quantity stepper with - / + buttons, range 1-6, default 1, animated spring bounce on quantity change
    - Live price breakdown: unit price, quantity multiplier, divider, total with brand amber highlight
    - "Continue" CTA button fixed at bottom showing total price (e.g. "Continue · $15.00"), disabled if beer is out or cooling
    - Inventory watchdog: if `availability_status` changes to `out` during viewing, shows Alert and navigates back to beer list
    - Supabase realtime subscription on taps table for live temperature and availability updates (same merge pattern as beer list)
    - BeerBot dark theme, FadeIn/FadeInDown staggered entrance animations, safe area insets
  - Updated `app/(main)/venues/[id].tsx`:
    - Beer card tap now navigates to `/(main)/order/configure` with `tapId` and `venueId` params
    - Fixed `react-hooks/exhaustive-deps` lint warning by adding `id` to `renderBeerCard` dependency array
  - `npx tsc --noEmit` passes
  - `npx expo lint` passes (0 errors, 0 warnings)
- Files changed:
  - `app/(main)/order/configure.tsx` — beer detail + order configuration screen (new)
  - `app/(main)/venues/[id].tsx` — updated navigation to configure screen + lint fix
- **Learnings:**
  - Reanimated `withSpring` for quantity stepper animation: set `scale.value = 1.15` immediately then `withSpring(1, ...)` for a satisfying bounce effect
  - The configure screen reuses the same `['venue-taps', venueId]` TanStack Query key as the beer list, so navigating forward gets instant data from cache with no refetch — just `useMemo` to find the specific tap from the cached array
  - For realtime subscriptions on detail screens, subscribe to the same venue channel (not individual tap) since Supabase `postgres_changes` filter is on `venue_id` — filter the specific tap in the `setQueryData` callback
  - `Alert.alert()` with a callback on "OK" is the right pattern for inventory drop alerts — it blocks interaction until dismissed, then navigates back
  - Using a `hasNavigatedAway` ref prevents double-navigation from the inventory watchdog effect firing multiple times as the tap data updates
  - When adding route params to navigation calls in `useCallback`, remember to add them to the dependency array or ESLint `exhaustive-deps` will warn
---

